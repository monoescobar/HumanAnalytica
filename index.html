<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Human Analytica is an AI-driven electronic art series exploring human vulnerability amid shifting power, blending classical bodies with unsettling distortions to provoke thought and discomfort">
    <title>Human Analytica</title>
    <!-- Updated: 25:08:09:19:56:00 -->
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icon-512x512.png">
    <link rel="apple-touch-icon" sizes="192x192" href="icon-192x192.png">
    <link rel="apple-touch-icon" sizes="512x512" href="icon-512x512.png">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="loading">
        <span class="text">Loading Next</span>
    </div>
    
    <div id="video-container">
        <video id="video" autoplay muted loop playsinline></video>
        <video id="video2" autoplay muted loop playsinline style="opacity: 0;"></video>
        
        <div id="sound-notification">
            <span class="text">Sound Off</span>
        </div>

        <div id="next-button">
            <span class="text">Info</span>
        </div>
    <!-- Button width CSS moved to styles.css -->
        </div>
        
        <div id="human-analytica-button">
            <span class="text">escob.art</span>
        </div>
        
        <div id="info-area">
            <h2>Human Analytica</h2>
            
            <!-- Desktop content -->
            <div class="desktop-content">

                <p>Human Analytica is a multimedia art series exploring the subtle, yet deeply unsettling dynamics of human interaction in our current era Using advanced AI diffusion techniques, each piece merges classical body figures and historic art poses with dreamlike dysmorphism: bodies stretch, merge, melt, and intertwine, capturing both vulnerability and exposure.
</p>
                <p>A deliberate mix of artistic references—from historic masterpieces to modern motifs—serves to amplify the sense of beauty disrupted by overt distortions. In this tension lies an ironic disturbance: viewers may grasp a sense of aesthetic discomfort instantly or uncover further unease on closer inspection. This interplay between elegance and abnormality is at the heart of the series’ critique.
</p>
                <p>Human Analytica exists not only as a sequence of digital artworks, but as an electronic art experience—the website itself forms part of the artwork. Every interaction, including this text and the “info” button, is woven into the overall concept: an immersive space where art, technology, and the theme of human interaction converge.
</p>
                <p>If you seek to understand, reflect, or reimagine the state of our humanity in times of power shifts and unsettling connection, allow yourself to linger. Discomfort may surface quickly, but meaning emerges gradually—through the interplay of form, distortion, and digital presence.
</p>
            </div>
            
            <!-- Mobile content -->
            <div class="mobile-content">
                <p>Human Analytica is a multimedia art series exploring unsettling human interactions. Using AI diffusion, it merges classical figures with dreamlike dysmorphism: bodies stretch, merge, melt, capturing vulnerability and exposure. Mixing historic and modern art reveals beauty disrupted by distortions, creating ironic disturbance. The website is part of electronic art, weaving art, and technology, inviting reflection on humanity amid power shifts where discomfort and meaning emerge</p>
                  </div>
        </div>
        
        <div id="device-info">
            <div id="device-type"></div>
            <div id="video-count"></div>
            <div id="current-video"></div>
            <div id="sound-status"></div>
            <div id="last-modified">Modified: 19:01:52</div>
        </div>
    </div>

    <!-- Load video URLs -->
    <script src="video-urls.js"></script>
    <script src="main.js"></script>
            // Immediately hide sound notification
            soundNotification.classList.remove('show');
            
            // Handle user-triggered loading (double-tap/double-click)
            // ...handled in main.js...
            
            const nextIndex = (currentVideoIndex + 1) % videoList.length;
            console.log(`Loading next video: ${nextIndex + 1}/${videoList.length}${isUserTriggered ? ' (with UI)' : ' (silent)'}`);
            
            isTransitioning = true;
            
            // Load next video in inactive video element
            const videoUrl = videoList[nextIndex];
            const fileName = videoUrl.split('/').pop().split('?')[0];
            
            inactiveVideo.src = videoUrl;
            inactiveVideo.muted = activeVideo.muted; // Match sound state
            inactiveVideo.load();
            
            inactiveVideo.onloadeddata = () => {
                console.log('Next video loaded, starting crossfade...');
                
                // Start playing the new video
                inactiveVideo.play().then(() => {
                    // Crossfade: fade out current, fade in next
                    activeVideo.style.opacity = '0';
                    inactiveVideo.style.opacity = '1';
                    
                    // After transition completes, swap video elements
                    setTimeout(() => {
                        // Stop the old video and hide it properly
                        activeVideo.pause();
                        activeVideo.style.opacity = '0';
                        
                        // Swap active/inactive videos
                        [activeVideo, inactiveVideo] = [inactiveVideo, activeVideo];
                        
                        // Ensure the new active video is fully visible and inactive is hidden
                        activeVideo.style.opacity = '1';
                        inactiveVideo.style.opacity = '0';
                        
                        // Update tracking
                        currentVideoIndex = nextIndex;
                        document.getElementById('current-video').textContent = `Now: ${fileName}`;
                        
                        // Hide loading screen and bottom buttons after transition (only if they were shown)
                        if (isUserTriggered) {
                            loading.classList.remove('show');
                            nextButton.classList.remove('show');
                            humanAnalyticaButton.classList.remove('show');
                        }
                        
                        isTransitioning = false;
                        console.log('Crossfade complete - active video opacity:', activeVideo.style.opacity, 'inactive video opacity:', inactiveVideo.style.opacity);
                    }, 800); // Match CSS transition duration
                    
                }).catch(error => {
                    console.log('Error playing next video:', error);
                    if (isUserTriggered) {
                        loading.classList.remove('show');
                        nextButton.classList.remove('show');
                        humanAnalyticaButton.classList.remove('show');
                    }
                    isTransitioning = false;
                });
            };
            
            inactiveVideo.onerror = () => {
                console.log('Error loading next video, trying another...');
                if (isUserTriggered) {
                    loading.classList.remove('show');
                    nextButton.classList.remove('show');
                    humanAnalyticaButton.classList.remove('show');
                }
                isTransitioning = false;
                setTimeout(() => loadNextVideo(isUserTriggered), 1000);
            };
        }

        // Shuffle array function
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Load and play video
        function loadVideo(index) {
            try {
                if (index >= videoList.length) index = 0;
                currentVideoIndex = index;
                
                const videoUrl = videoList[index];
                const fileName = videoUrl.split('/').pop().split('?')[0];
                updateStatus(`Loading video ${index + 1}/${videoList.length}...`);
                console.log(`Loading video ${index + 1}/${videoList.length}: ${videoUrl}`);
                
                activeVideo.src = videoUrl;
                activeVideo.load();
                
                activeVideo.onloadeddata = () => {
                    console.log('Video loaded successfully');
                    document.getElementById('current-video').textContent = `Now: ${fileName}`;
                    // Loading element is now hidden by default
                    
                    activeVideo.play().then(() => {
                        isPlaying = true;
                        console.log('Video playing');
                    }).catch(error => {
                        console.log('Autoplay prevented:', error);
                        // No visible message - user will see video is paused
                    });
                };
                
                activeVideo.onerror = (error) => {
                    console.error('Video error:', error);
                    // No visible error message - just try next video
                    setTimeout(() => {
                        const nextIndex = (currentVideoIndex + 1) % videoList.length;
                        loadVideo(nextIndex);
                    }, 1000);
                };
                
                activeVideo.onended = () => {
                    loadNextVideo(false); // Don't show UI when video naturally ends
                };

            } catch (error) {
                console.error('Error loading video:', error);
                // No visible error message - just try next video
                setTimeout(() => {
                    const nextIndex = (currentVideoIndex + 1) % videoList.length;
                    loadVideo(nextIndex);
                }, 1000);
            }
        }

        // Sync button widths - make Info button match Human Analytica width
    // Removed syncButtonWidths logic so Info button keeps its own width

        // Open Human Analytica website
        function openHumanAnalytica() {
            window.open('https://escob.art', '_self');
            console.log('Opening escob.art website in same tab');
        }
        
        // Toggle info area visibility
        function toggleInfoArea() {
            console.log('Info area toggle requested, current state:', infoAreaVisible);
            
            if (infoAreaVisible) {
                // Hide info area
                infoArea.classList.remove('show');
                infoAreaVisible = false;
                console.log('Info area hidden');
                
                // Don't automatically show bottom buttons - they should stay hidden until user interaction
                console.log('Bottom buttons remain hidden until next user interaction');
            } else {
                // Show info area
                infoArea.classList.add('show');
                infoAreaVisible = true;
                
                // Hide bottom buttons when info area is shown
                nextButton.classList.remove('show');
                humanAnalyticaButton.classList.remove('show');
                
                console.log('Info area shown, bottom buttons hidden');
            }
        }

        // Toggle mute and show notification
        function toggleMute() {
            // Immediately hide loading and show sound notification
            loading.classList.remove('show');
            
            const newMutedState = !activeVideo.muted;
            
            // Apply to both videos
            activeVideo.muted = newMutedState;
            inactiveVideo.muted = newMutedState;
            
            // Force video reload on mobile if audio context is lost
            if (!newMutedState && activeVideo.paused) {
                activeVideo.load();
                activeVideo.play().catch(error => {
                    console.log('Audio context may be suspended, trying to resume...');
                    // Try to resume audio context if available
                    if (window.AudioContext || window.webkitAudioContext) {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        if (window.audioContext && window.audioContext.state === 'suspended') {
                            window.audioContext.resume();
                        }
                    }
                });
            }
            
            showSoundNotification();
            console.log(`Audio ${newMutedState ? 'muted' : 'unmuted'}`);
        }

        // Show initial notification - instructions for desktop, sound status for mobile
        function showInitialNotification() {
            const text = soundNotification.querySelector('.text');
            const mobile = isMobile();
            
            if (mobile) {
                // Mobile: show tap instructions on first load
                text.innerHTML = 'One Tap<br>Sound On<br><br>Two Taps<br>Next One';
            } else {
                // Desktop: show instructions on first load
                const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                if (isMac) {
                    text.innerHTML = 'One Click Sound On<br><br>Two Clicks Next One<br><br>Cmd + Click Full Screen';
                } else {
                    text.innerHTML = 'One Click Sound On<br><br>Two Clicks Next One<br><br>Ctrl + Click Full Screen';
                }
            }
            
            // Update sound status in device info
            document.getElementById('sound-status').textContent = `Sound: ${activeVideo.muted ? 'Off' : 'On'}`;
            
            // Clear existing timeout
            if (notificationTimeout) clearTimeout(notificationTimeout);
            
            // Show sound notification and buttons
            soundNotification.classList.add('show');
            nextButton.classList.add('show');
            humanAnalyticaButton.classList.add('show');
            
            // Hide after 4 seconds (longer for instructions)
            const hideDelay = 4000;
            notificationTimeout = setTimeout(() => {
                soundNotification.classList.remove('show');
                nextButton.classList.remove('show');
                humanAnalyticaButton.classList.remove('show');
                hasShownInitialInstructions = true; // Mark instructions as shown
            }, hideDelay);
        }

        // Show sound notification with current state
        function showSoundNotification() {
            const text = soundNotification.querySelector('.text');
            const mobile = isMobile();
            
            // After initial instructions, always show normal sound status
            if (activeVideo.muted) {
                text.textContent = 'Sound Off';
            } else {
                text.textContent = 'Sound On';
            }
            
            // Update sound status in device info
            document.getElementById('sound-status').textContent = `Sound: ${activeVideo.muted ? 'Off' : 'On'}`;
            
            // Clear existing timeout (including initial notification timeout)
            if (notificationTimeout) clearTimeout(notificationTimeout);
            
            // Mark initial instructions as shown when user interacts (fixes early click glitch)
            if (!hasShownInitialInstructions) {
                hasShownInitialInstructions = true;
                console.log('🔧 Early interaction detected - marking initial instructions as shown');
            }
            
            // Increment sound toggle count
            soundToggleCount++;
            console.log(`🔊 Sound toggle count: ${soundToggleCount}`);
            
            // Only show sound notification area and text for first 2 toggles
            if (soundToggleCount <= 2) {
                soundNotification.classList.add('show');
                console.log(`✅ Showing sound notification (toggle ${soundToggleCount}/2)`);
            } else {
                console.log(`❌ Sound notification hidden (toggle ${soundToggleCount} > 2)`);
            }
            
            // Always show bottom buttons regardless of toggle count
            nextButton.classList.add('show');
            humanAnalyticaButton.classList.add('show');
            
            // Hide after 4 seconds
            notificationTimeout = setTimeout(() => {
                soundNotification.classList.remove('show');
                nextButton.classList.remove('show');
                humanAnalyticaButton.classList.remove('show');
            }, 4000);
        }

        // Toggle device info visibility with enhanced debugging
        function toggleDeviceInfo() {
            console.log('🔧 toggleDeviceInfo() CALLED');
            console.log('📋 Device info element exists:', !!deviceInfo);
            console.log('📋 Current classes:', deviceInfo.className);
            console.log('📋 Current opacity:', window.getComputedStyle(deviceInfo).opacity);
            
            // Clear any existing timeout
            if (deviceInfoTimeout) clearTimeout(deviceInfoTimeout);
            console.log('⏰ Cleared existing timeout');
            
            // Always show the info when toggled
            infoVisible = true;
            deviceInfo.classList.add('show');
            console.log('✅ Added "show" class to device info');
            console.log('📋 New classes after show:', deviceInfo.className);
            
            // Force style recalculation
            deviceInfo.offsetHeight; // Trigger reflow
            console.log('🔄 Forced style recalculation');
            
            // Check computed style after change
            setTimeout(() => {
                const computedOpacity = window.getComputedStyle(deviceInfo).opacity;
                console.log('📋 Computed opacity after show:', computedOpacity);
                if (computedOpacity === '0') {
                    console.log('⚠️ WARNING: Opacity is still 0 - CSS might not be applied');
                } else {
                    console.log('✅ SUCCESS: Device info should be visible');
                }
            }, 100);
            
            console.log('✅ DEVICE INFO SHOWN - 3-finger gesture detected successfully!');
            
            // Hide device info after 4 seconds
            deviceInfoTimeout = setTimeout(() => {
                infoVisible = false;
                deviceInfo.classList.remove('show');
                console.log('⏰ Device info auto-hidden after 4 seconds');
            }, 4000);
        }

        // Attach event listeners to video container
        function attachVideoEventListeners() {
            const videoContainer = document.getElementById('video-container');
            let touchStartTime = 0;
            let clickCount = 0;
            let clickTimer = null;
            // Desktop-only: Ctrl+Click for fullscreen
            videoContainer.addEventListener('click', (e) => {
                if (!isMobile() && (e.ctrlKey || e.metaKey)) {
                    // Trigger on Ctrl (Windows/Linux) or Command (Mac)
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        videoContainer.requestFullscreen();
                    }
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
            }, true); // Use capture to run before other click logic
            
            // Mobile tap detection variables
            let tapCount = 0;
            let tapTimer = null;
            let lastTapTime = 0;
            
            // Gesture tracking variables for maximum finger count detection
            let gestureStartTime = 0;
            let maxFingers = 0;
            let gestureTimer = null;
            let gestureInProgress = false;
            
            // (removed duplicate declaration)
            
            // Handle mouse clicks (desktop)
            videoContainer.addEventListener('click', (e) => {
                // Don't trigger if clicking on info button or human analytica button
                if (e.target.closest('#next-button') || e.target.closest('#human-analytica-button')) return;
                
                clickCount++;
                
                if (clickCount === 1) {
                    clickTimer = setTimeout(() => {
                        // Single click - toggle mute
                        console.log('Single click detected - toggle mute');
                        toggleMute();
                        clickCount = 0;
                    }, 300); // 300ms delay to detect double click
                } else if (clickCount === 2) {
                    // Double click - load next video
                    clearTimeout(clickTimer);
                    console.log('Double click detected - load next video');
                    loadNextVideo();
                    clickCount = 0;
                }
            });
            
            // Maximum finger count detection system
            videoContainer.addEventListener('touchstart', (e) => {
                // Don't trigger if touching info button or human analytica button
                if (e.target.closest('#next-button') || e.target.closest('#human-analytica-button')) return;
                e.preventDefault();
                
                const fingers = e.touches.length;
                
                // Start new gesture or update existing one
                if (!gestureInProgress) {
                    // Start new gesture
                    gestureInProgress = true;
                    gestureStartTime = Date.now();
                    maxFingers = fingers;
                    
                    console.log(`🎯 NEW GESTURE STARTED: ${fingers} finger(s)`);
                    
                    // Set timer to execute gesture after 200ms window
                    gestureTimer = setTimeout(() => {
                        executeGesture();
                    }, 200);
                } else {
                    // Update existing gesture
                    if (fingers > maxFingers) {
                        maxFingers = fingers;
                        console.log(`� GESTURE UPDATED: max fingers now ${maxFingers}`);
                    }
                }
                
                console.log(`📍 Touch coordinates:`, Array.from(e.touches).map((t, i) => `F${i+1}:(${Math.round(t.clientX)}, ${Math.round(t.clientY)})`));
            });
            
            // Track finger changes during gesture
            videoContainer.addEventListener('touchmove', (e) => {
                if (e.target.closest('#next-button') || e.target.closest('#human-analytica-button')) return;
                
                const fingers = e.touches.length;
                
                // Update max fingers if we detect more during the gesture
                if (gestureInProgress && fingers > maxFingers) {
                    maxFingers = fingers;
                    console.log(`🔄 GESTURE UPDATE: max fingers increased to ${maxFingers}`);
                }
            });
            
            // Handle gesture completion
            videoContainer.addEventListener('touchend', (e) => {
                if (e.target.closest('#next-button') || e.target.closest('#human-analytica-button')) return;
                
                const remainingTouches = e.touches.length;
                console.log(`👆 FINGER LIFTED: ${remainingTouches} finger(s) remaining`);
                
                // If all fingers lifted, complete gesture immediately
                if (remainingTouches === 0 && gestureInProgress) {
                    console.log('🏁 ALL FINGERS LIFTED - executing gesture immediately');
                    clearTimeout(gestureTimer);
                    executeGesture();
                }
            });
            
            // Execute the gesture based on maximum finger count detected
            function executeGesture() {
                if (!gestureInProgress) return;
                
                const duration = Date.now() - gestureStartTime;
                console.log(`🎯 EXECUTING GESTURE: ${maxFingers} max fingers (${duration}ms duration)`);
                
                // Execute based on maximum finger count detected
                if (maxFingers === 1) {
                    // Single finger - handle tap detection for single/double tap
                    const currentTime = Date.now();
                    
                    if (currentTime - lastTapTime < 400) {
                        // Double tap detected
                        clearTimeout(tapTimer);
                        console.log('✅ DOUBLE TAP → NEXT VIDEO');
                        loadNextVideo();
                        tapCount = 0;
                    } else {
                        // Single tap - wait to see if there's a second tap
                        tapCount = 1;
                        tapTimer = setTimeout(() => {
                            if (tapCount === 1) {
                                console.log('✅ SINGLE TAP → TOGGLE SOUND');
                                toggleMute();
                            }
                            tapCount = 0;
                        }, 300);
                    }
                    
                    lastTapTime = currentTime;
                } else if (maxFingers === 2) {
                    console.log('✅ 2 FINGERS → SHOW INFO AREA');
                    toggleDeviceInfo();
                } else if (maxFingers >= 3) {
                    console.log(`✅ ${maxFingers} FINGERS → SHOW INFO AREA (multi-touch)`);
                    toggleDeviceInfo();
                } else {
                    console.log('❌ No valid gesture detected');
                }
                
                // Reset gesture tracking
                gestureInProgress = false;
                maxFingers = 0;
                gestureStartTime = 0;
            }
            
            // Just track when touch ends for logging - REMOVED, replaced by gesture system
            
            // Prevent context menu
            videoContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case ' ':
                case 'enter':
                    e.preventDefault();
                    if (activeVideo.paused) {
                        activeVideo.play();
                    } else {
                        loadNextVideo();
                    }
                    break;
                case 'm':
                    toggleMute();
                    break;
                case 'i':
                    toggleDeviceInfo();
                    break;
                case 't':
                    // Test function - press 't' to test device info display
                    console.log('🧪 TEST: Manual device info toggle');
                    toggleDeviceInfo();
                    break;
            }
        });

        // Click/touch anywhere on video to toggle sound
        attachVideoEventListeners();
        // Desktop: Show hint for Ctrl+Click fullscreen
        if (!isMobile()) {
            setTimeout(() => {
                const infoArea = document.getElementById('info-area');
                if (infoArea && !document.getElementById('fullscreen-hint')) {
                    let hint = document.createElement('div');
                    hint.className = 'close-hint';
                    hint.id = 'fullscreen-hint';
                    hint.textContent = 'Ctrl+Click for fullscreen';
                    infoArea.appendChild(hint);
                }
            }, 1000);
        }

        // Handle page visibility changes (when returning from LinkedIn app)
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && isMobile()) {
                console.log('Page became visible again, checking audio state...');
                // Small delay to ensure page is fully active
                setTimeout(() => {
                    if (!activeVideo.muted && (activeVideo.paused || activeVideo.currentTime === 0)) {
                        console.log('Reloading video to restore audio context...');
                        const currentIndex = currentVideoIndex;
                        loadVideo(currentIndex);
                    }
                }, 500);
            }
        });

        // Handle window focus events (additional fallback)
        window.addEventListener('focus', () => {
            if (isMobile() && !activeVideo.muted && activeVideo.paused) {
                console.log('Window focused, attempting to resume video...');
                activeVideo.play().catch(error => {
                    console.log('Could not resume, reloading video...');
                    loadVideo(currentVideoIndex);
                });
            }
        });

        // Handle window resize to re-sync button widths
        window.addEventListener('resize', () => {
            setBottomButtonWidthsToWord('Human Analytica');
        });
    // Removed syncButtonWidths call on resize

        // Human Analytica button click handler (opens Human Analytica website)
        humanAnalyticaButton.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (humanAnalyticaButton.classList.contains('show')) {
                openHumanAnalytica();
            }
        });

        // Prevent touch events on Human Analytica button from bubbling to video
        humanAnalyticaButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        humanAnalyticaButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (humanAnalyticaButton.classList.contains('show')) {
                openHumanAnalytica();
            }
        });

        // INFO button click handler (toggles info area)
        nextButton.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (nextButton.classList.contains('show')) {
                toggleInfoArea();
            }
        });

        // Prevent touch events on INFO button from bubbling to video
        nextButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        nextButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (nextButton.classList.contains('show')) {
                toggleInfoArea();
            }
        });

        // Info area click/touch handlers (close when clicked/tapped)
        infoArea.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (infoAreaVisible) {
                toggleInfoArea();
            }
        });

        infoArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        infoArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (infoAreaVisible) {
                toggleInfoArea();
            }
        });

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Set button widths immediately to prevent jumping
            setBottomButtonWidthsToWord('Human Analytica');
            console.log('DOM Content Loaded, initializing...');
            init();
        });
        
        // Fallback initialization
        window.addEventListener('load', () => {
            console.log('Window loaded');
            if (videoList.length === 0) {
                console.log('Fallback initialization...');
                setTimeout(init, 500);
            }
        });

        console.log('Dreams and Poems - Simple Video Player Script Loaded');
        
        // Global test function for debugging
        window.testDeviceInfo = function() {
            console.log('🧪 GLOBAL TEST: Testing device info display');
            toggleDeviceInfo();
        };
        
        window.testThreeFingers = function() {
            console.log('🧪 SIMULATING 3-FINGER TOUCH');
            console.log('📋 Device info element:', deviceInfo);
            console.log('👀 Current classes:', deviceInfo.className);
            toggleDeviceInfo();
        };
    </script>
</body>
</html>